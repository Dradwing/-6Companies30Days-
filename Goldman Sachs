1
class Solution {
public:
    int maxPoints(vector<vector<int>>& points) {
        
        int ans=0;

        for(int l=0;l<points.size();l++)
        {
               
            map<pair<int,int>, int> m;
            for(int i=0;i<points.size();i++)
            {
                if(i==l)continue;
                 int y=(points[i][1]-points[l][1]);
                 int x=points[i][0]-points[l][0];

                 int gc=__gcd(x,y);
                 x=x/gc;
                 y=y/gc;
                 m[make_pair(y,x)]++;  
            }

            for(auto el:m){
                ans=max(ans,el.second+1);
            }
        }
        return ans==0?1:ans;
    }
};
2
class Solution {
public:
    bool validSquare(vector<int>& p1, vector<int>& p2, vector<int>& p3, vector<int>& p4) {

        double s2=sqrt(1.00*(p1[0]-p2[0])*(p1[0]-p2[0])+(1.00*(p1[1]-p2[1])*(p1[1]-p2[1])));
        double s3=sqrt(1.00*(p1[0]-p3[0])*(p1[0]-p3[0])+(1.00*(p1[1]-p3[1])*(p1[1]-p3[1])));

        if(s2==0||s3==0)return false;

        if(s2<s3){
            double s4=sqrt(1.00*(p1[0]-p4[0])*(p1[0]-p4[0])+(1.00*(p1[1]-p4[1])*(p1[1]-p4[1])));
            double s34=sqrt(1.00*(p3[0]-p4[0])*(p3[0]-p4[0])+(1.00*(p3[1]-p4[1])*(p3[1]-p4[1])));
            double s23=sqrt(1.00*(p2[0]-p3[0])*(p2[0]-p3[0])+(1.00*(p2[1]-p3[1])*(p2[1]-p3[1])));

            double d24=sqrt(1.00*(p2[0]-p4[0])*(p2[0]-p4[0])+(1.00*(p2[1]-p4[1])*(p2[1]-p4[1])));

            if(d24==s3&&(s2==s4&&s4==s34&&s34==s23))return true;
        }
        else if(s3<s2)
        {
            double s4=sqrt(1.00*(p1[0]-p4[0])*(p1[0]-p4[0])+(1.00*(p1[1]-p4[1])*(p1[1]-p4[1])));
            double s24=sqrt(1.00*(p2[0]-p4[0])*(p2[0]-p4[0])+(1.00*(p2[1]-p4[1])*(p2[1]-p4[1])));
            double s32=sqrt(1.00*(p3[0]-p2[0])*(p3[0]-p2[0])+(1.00*(p3[1]-p2[1])*(p3[1]-p2[1])));

            double d34=sqrt(1.00*(p3[0]-p4[0])*(p3[0]-p4[0])+(1.00*(p3[1]-p4[1])*(p3[1]-p4[1])));

            if(d34==s2&&(s3==s4&&s4==s24&&s24==s32))return true;
        }
        else
        {
            double d14=sqrt(1.00*(p1[0]-p4[0])*(p1[0]-p4[0])+(1.00*(p1[1]-p4[1])*(p1[1]-p4[1])));
            double s24=sqrt(1.00*(p2[0]-p4[0])*(p2[0]-p4[0])+(1.00*(p2[1]-p4[1])*(p2[1]-p4[1])));
            double s32=sqrt(1.00*(p3[0]-p2[0])*(p3[0]-p2[0])+(1.00*(p3[1]-p2[1])*(p3[1]-p2[1])));

            double d34=sqrt(1.00*(p3[0]-p4[0])*(p3[0]-p4[0])+(1.00*(p3[1]-p4[1])*(p3[1]-p4[1])));

            if(d14==s32&&(s3==d34&&d34==s24&&s24==s2))return true;
        }

        return false;



    }
};

3
class Solution {
public:
    int trailingZeroes(int n) {

        // count factors of 2 and 5 from 1 to n;
        // count of 2>>>> count of 5 -> ignore 2;
        // for 5-> n/5;
        // for 25-> n/25;
        // ... 
         int count = 0;
        while (n != 0) {
            int tmp = n / 5;
            count += tmp;
            n = tmp;
        }
        return count;
    }
};
4
class Solution {
public:
    int numberOfBoomerangs(vector<vector<int>>& points) {

        int ans=0;

    
        for(int l=0;l<points.size();l++)
        {
            
            unordered_map<double,int> m;
            
            for(int i=0;i<points.size();i++)
            {
                if(l==i)continue;
                double d=sqrt(1.00*(long long int)(points[i][0]-points[l][0])*(long long int)(points[i][0]-points[l][0])+1.00*(long long int)(points[i][1]-points[l][1])*(long long int)(points[i][1]-points[l][1]));
                m[d]++;
            }

            for(auto [d,cnt]:m)
            {
                if(cnt<2)continue;
                ans+=cnt*(cnt-1);
            }

        }
        return ans;
        
    }
};

5
class Solution {
public:
    bool isPossible(vector<int>& nums) {
        // either the curr element can be appeded otherwise it must form new sequence;

        unordered_map<int,int> m1,m2;

        for(int l=0;l<nums.size();l++)m1[nums[l]]++;

        for(int l=0;l<nums.size();l++){
            if(m1[nums[l]]==0)continue;

            if(m2[nums[l]]>0){
                m1[nums[l]]--;
                m2[nums[l]]--;
                m2[nums[l]+1]++;

            }
            else if(m1[nums[l]+1]>0&&m1[nums[l]+2]>0){
                m1[nums[l]]--;
                m1[nums[l]+1]--;
                m1[nums[l]+2]--;
                m2[nums[l]+3]++;
            }
            else return false;
        }
        return true;
    }
};

6
class Solution {
public:
    int minimumCardPickup(vector<int>& cards) {
        
        int ans=INT_MAX;
        unordered_map<int,int> m;
        for(int l=0;l<cards.size();l++)
        {
            if(m[cards[l]]!=0)ans=min(ans,(l+1-m[cards[l]]+1));
            m[cards[l]]=l+1;
        }
        return ans==INT_MAX?-1:ans;
        
    }
};
